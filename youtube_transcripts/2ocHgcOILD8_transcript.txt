Neste vÃ­deo vamos continuar a desenvolver a aplicaÃ§Ã£o do Lord of the Rings jÃ¡ tÃ­nhamos implementado este botÃ£o quando se carrega aqui vai ao servidor buscar atravÃ©s de uma API buscar uma lista de personagens do Senhor dos AnÃ©is reparem eu vou simular agora que o servidor estÃ¡ lento carrego aqui nada acontece fico na dÃºvida Oi finalmente Apareceu OK se isto demorasse mais tempo ainda era mais estranho mais provÃ¡vel era o carregar vÃ¡rias vezes naquele botÃ£o e fazer vÃ¡rios pedidos ao servidor desnecessariamente Este Ã© um dos problemas que queremos resolver o outro Ã© que ainda nÃ£o estÃ¡ a funcionar o detalhe tÃ¡ sempre vai aparecer Pedro e agora quero que apareÃ§a a personagem respectiva a razÃ£o para isso estar a acontecer Ã© porque o repositÃ³rio jÃ¡ estÃ¡ implementado para o get characters que obtÃ©m a lista dos personagens mas ainda nÃ£o estÃ¡ implementado para o get Character neste momento ainda estÃ¡ fixo entÃ£o nÃ³s vamos fazer uma coisa parecida com esta vamos chamar Api para obter os dados de um certo personagem e retornar os e retornar um objet com essa informaÃ§Ã£o vamos lembrar-nos daqui da api e reparar que existe de facto aqui nÃ³s estÃ¡vamos a usar este barra Character mas se Ã  frente do Barra Character lhe passarmos aqui um ID ele na realidade vai obter especificamente os dados deste personagem com este ID dito isto vamos vamos comeÃ§ar por Copiar esta parte para aqui e aqui em vez de vamos deixar este Mas vamos colocar aqui o ID Ã  frente este ID Ã© o ID que ele recebe aqui por parÃ¢metro portanto se eu quero obter o com o certo ID eu chamo api com esse ID agora vou Ã  mesma verificar ten a mesma que verificar se o status code Ã© 200 ou Ã© um erro sÃ³ que aqui dentro a informaÃ§Ã£o vai ser diferente Vamos sÃ³ perceber que informaÃ§Ã£o Ã© essa aqui no rest console Ok eu jÃ¡ coloquei aqui um exemplo de um ID Isto Ã© o exemplo de um id de um personagem portanto se eu fizer submit disto eu tenho esta resposta ou seja obtenho apenas Ã© muito parecida com a outra existe h mesmo um DOC com uma lista eh mas dentro da lista aparece apenas os dados do personagem que me interessa EntÃ£o como Isto Ã© muito parecido podemos aproveitar a maior parte do cÃ³digo jÃ¡ existe vamos ter Ã  mesma um characters Jason sÃ³ que agora dentro deste characters Jason vai estar apenas um Ãºnico objeto e portanto podemos obtÃª-lo diretamente podemos criar aqui uma variÃ¡vel que vai ter o Ãºnico personagem que estÃ¡ lÃ¡ dentro Character Jason que Ã© simplesmente o characters Jason na posiÃ§Ã£o zero e agora Ã© sÃ³ retornar diretamente o Character from map desse Character Jason lembro que o que isto faz Ã© construir um objeto Character a partir do Jason que foi obtido do Servidor Ok jÃ¡ sabemos que este await para estar sublinhado Ã© porque falta aqui um a e tambÃ©m jÃ¡ sabemos que quando colocamos a funÃ§Ã£o aass ela tem que retornar um Future vamos retirar daqui este ponto de interrogaÃ§Ã£o assumir que o estÃ¡ sempre preenchido e a partir deste momento ao alterarmos isto o nosso Character det Tail page deixou de funcionar por quÃª Porque o que eu faÃ§o aqui Ã© obter o get Character de forma sÃ­ncrona estou Ã  espera de opt de forma sÃ­ncrona mas isto agora Ã© assÃ­ncrono e portanto este Character Ã© um Future Character mas aquilo que eu quero aqui Ã© mesmo o Character quero poder obter o name do Character o b do Character e o death do Character Se fÃ´ssemos usar a mesma tÃ©cnica que usamos no Ãºltimo vÃ­deo a forma de eu converter um Future em algo que nÃ£o Ã© um Future Ã© um await ou seja bloquear esta chamada de forma a que ele fica aqui Ã  espera que ele dÃª um get Character quando finalmente estiver pronto EntÃ£o devolve jÃ¡ o Character agora jÃ¡ devolve o mesmo e nÃ£o o Future Character O problema Ã© que para isto ter aqui um aight o build tinha que ser Aim E isso nÃ£o Ã© possÃ­vel entÃ£o como Ã© que vamos resolver isto vou agora mostrar aqui com os slides para percebermos melhor o que estÃ¡ a acontecer basicamente eu quero quando carrega aqui numa opÃ§Ã£o chamar o Character detail page por sua vez vai chamar o Build para construir esta pÃ¡gina Com base no ID que estÃ¡ associado a este item que aqui estÃ¡ e ele hÃ¡ de ir ao servidor e fazer isso o problema Ã© que o ir ao servidor que Ã© este repositÃ³rio get Character demora algum tempo portanto Se eu escolher aqui este aragorn o ID dele Ã© este que aqui estÃ¡ que Ã© este e vou chamar Esta funÃ§Ã£o mas esta funÃ§Ã£o agora demora alguns segundos porque tÃ¡ a ir ao servidor e como tal eu nÃ£o posso parar o build ele tem que mostrar imediatamente alguma coisa quando eu carrego aqui ele tem que mostrar logo um ecrÃ£ muito rapidamente nÃ£o pode darse a luz de ficar Ã  espera do Servidor e portanto uma das hipÃ³teses que nÃ³s temos Ã© comeÃ§ar por criar uma variÃ¡vel Character que Ã© o nosso caracter nÃ© o nosso personagem aliÃ¡s que comeÃ§a a porstar a nulo e depois em paralelo de forma assÃ­ncrona eu chamo repositÃ³rio getc e deixo-o a trabalhar mas reparem que eu nÃ£o ele nÃ£o bloqueia como eu digo que estou aqui a dizer de forma assÃ­ncrona significa que ele nÃ£o estÃ¡ a bloquear a construÃ§Ã£o da pÃ¡gina portanto eu faÃ§o o igual a nul e chamo logo o build com o igual a nul Claro que como eu nÃ£o tenho os dados do personagem eu vou ter uma coisa deste gÃ©o nÃ£o aparece o nome dele aparece-me aqui este Born nul da nul horrÃ­vel Ok mas eventualmente Esta funÃ§Ã£o vai terminar a chamada o servidor hÃ¡ de responder com alguma resposta passo a redundÃ¢ncia e nessa altura eu posso preencher esta variÃ¡vel o Carter pode passar a ter o valor que veio do servidor quando chegar a resposta uma vez que eu tenha este esta variÃ¡vel preenchida eu posso voltar a chamar o Build para ele refrescar o ecrÃ£ e agora jÃ¡ vai funcionar corretamente entÃ£o a primeira coisa que eu tenho que fazer Ã© ter uma variÃ¡vel Character eh nesta neste widget e a partir do momento em que eu tenho o uma variÃ¡vel significa que o widget passa a ter estado se o widget passa a ter estado eue tenho que passar a stateful logo vou converter isto para stateful widget agora vou criar entÃ£o aqui uma variÃ¡vel Character ponto interrogaÃ§Ã£o para poder ser nul e aqui o que eu vou fazer Ã© este Character vai passar a ser Future Character e isto ainda nÃ£o me dÃ¡ nada mas eu quero agora perceber como Ã© que eu obtenho a partir de um Future como Ã© que eu sei quando Ã© que ele terminou como Ã© que eu sei que este Future jÃ¡ tem dados lÃ¡ dentro deixa voltar aqui aos slides Portanto o que eu agora quero perceber Ã© como Ã© que eu sei que isto aconteceu como Ã© que eu sei que chegou a resposta bem Vamos sÃ³ voltar aqui um bocadinho atrÃ¡s eu jÃ¡ falei sobre isto mas nÃ£o Ã© demais Recordar um feature Ã© um objeto que pode ter dois estados ou estÃ¡ em curso ou estÃ¡ completo sendo que caso esteja completo pode ter tido sucesso ou pode ter dado um erro quando eu chamo Esta funÃ§Ã£o ela no inÃ­cio vai estar em curso e e eventualmente passado algum tempo vai estar completo jÃ¡ tÃ­nhamos visto que uma das formas que eu tenho de saber quando Ã© que ela estÃ¡ completa Ã© o aight sÃ³ quando esta funÃ§Ã£o este futures passar para o estado completo Ã© que ele sai deste aight com o Character pretendido isto tem o problema que bloqueia a execuÃ§Ã£o EntÃ£o qual Ã© a soluÃ§Ã£o para isto o Future Tem uma funÃ§Ã£o chamada den Esta funÃ§Ã£o den pode ser aplicada a qualquer Future Ok lembro que isto retorna um Future tÃ¡ aqui Future e portanto eu posso chamar isto pon den e o que Ã© que o den tem lÃ¡ dentro uma funÃ§Ã£o que Ã© chamada um lambda que Ã© chamado quando a funÃ§Ã£o termina e o lambda inclusivamente dÃ¡-me logo qual Ã© o Character que ele obteve mesmo o Character jÃ¡ nÃ£o Ã© o futuro Ã© mesmo o Car o que Ã© que eu posso fazer nessa altura atribuir esse Car Ã  minha variÃ¡vel que estava lÃ¡ em cima a nul e que agora passou a nÃ£o estar aul Vamos entÃ£o fazer esse processo aqui portanto Future Character then ok ele faz-me logo isto eu vou substituir este value por Character para se perceber que o que ele obtÃ©m Ã© um Character vou transformar isto num bloco para ficar mais claro e o que eu quero fazer aqui dentro Ã© basicamente Character igual a car agora isto nÃ£o Ã© suficiente para os que estÃ£o mais atentos e se lembram disto Eu quando quero refrescar o ecrÃ£ quando eu altero o estado de um widget de um stateful Wi eu tenho que chamar o set state para indicar que ele tem que repintar o ecrÃ£ Tem que voltar a chamar o build e por isso eu vou colocar aqui um set state aqui dentro e este esta alteraÃ§Ã£o de estado tem que ser feita aqui dentro do Set state falta-nos apenas corrigir estes trÃªs casos Aqui Esta variÃ¡vel nÃ£o existe agora chama-se undac ele agora nÃ£o gosta que nÃ³s tentamos aceder ao name des de uma variÃ¡vel que pode estar a nul e de facto na primeira vez Que el vai fazer oild ela vai estar a nul e como tal vamos usar aqui o save operator e se resolve o problema aqui aqui mesmo assim nÃ£o resolve vamos ter que usar isto para dizer que caso ela esteja nul entÃ£o colocamos uma string vazia agora antes de correr isto eu vou colocar aqui um debug print e jÃ¡ vamos perceber porque Ã© que isto Ã© importante fazer aqui um restart Vamos entÃ£o OB os Cars e faz conta vou aqui a este isto aparentemente funcionou bem mas reparem o que que estÃ¡ acontecer ele estÃ¡ permanentemente obter Car do Servidor para nÃ£o massar e vamos perte aquiar que cada vez que eu ch build neste chas vees a primeir vez eu build oio ele comeÃ§a inici este processo de chamar o get de forma assÃ­ncrona isto hÃ¡ de ser eventualmente chamado mais tarde nÃ£o Ã© logo chamado desenha inicialmente isto com o Character anu passado alguns segundos vem a resposta do servidor ao vir uma resposta do Servidor esta funÃ§Ã£o Ã© chamada Esta funÃ§Ã£o aqui Ã© chamada e nomeadamente ele coloca o Character no Character tudo bem mas faz um set state ao fazer um set state chama novamente o build ora ao fazer novamente o build o que Ã© que ele vai fazer novamente um Pida ao servidor e anda por aqui fora claro que como o Car jÃ¡ tÃ¡ preenchido a gente nÃ£o dÃ¡ conta disto a gente olha para o ecrÃ£ E parece que estÃ¡ tudo bem mas na realidade ele estÃ¡ a massacrar o servidor desnecessariamente o que nÃ³s querÃ­amos era que este cÃ³digo aqui estÃ¡ fosse chamado apenas da primeira vez que nÃ³s entramos nesta pÃ¡gina e que os builds subsequentes nÃ£o voltassem a chamar isto para isso nÃ³s vamos usar aqui uma funÃ§Ã£o que existe em todos os widgets stateful que Ã© o init state fiz control o para fazer override ao init state primeira coisa que devemos fazer Ã© chamar o super pinit state e agora vamos simplesmente copiar isto tudo para ali nÃ£o precisamos de alterar mais nada isto em princÃ­pio vai ser corrido sÃ³ uma vez para confirmarmos vamos correr isto novamente vamos entÃ£o chamar o get characters e agora aqui e pronto fez um Ãºnico vou obter o Character do Servidor nÃ£o fez mais nenhum Claro que se eu agora voltar atrÃ¡s e chamar outro ele vai voltar a obter o caror do servidor e agora jÃ¡ temos isto a funcionar corretamente sempre obter repararam que temporariamente aparece ali os os tais nulos mas logo que tenha a resposta do Servidor ele volta a fazer um build e refresca o ecrÃ£ com informaÃ§Ã£o correta esta tÃ©cnica funciona sempre que queremos um widget que depende de uma chamada a uma funÃ§Ã£o assÃ­ncrona o princÃ­pio Ã© sempre o mesmo o widget deve ser stateful devemos ter uma variÃ¡vel que guarda os aquilo que pretendemos mostrar no ecrÃ£ mas que inicialmente estÃ¡ nul e temos um init state que vai preencher essa variÃ¡vel no den de um futuro de uma funÃ§Ã£o que retorna um Future e que nessa nessa altura tambÃ©m faz um set state embora esta tÃ©cnica funcione sempre Ã© um bocadinho chata testar sempre a implementar e como tal vamos aprender agora uma forma mais Expedita mais simples de resolver o mesmo problema como podem ver voltamos aqui ao estado inicial do nosso wiget ele passou a ser novamente um stateless nÃ£o tem um init state nÃ£o tem um Car pode ser nulo nÃ£o tem um den nÃ£o tem nada daquelas tÃ©cnicas que vimos antes porque nÃ³s agora vamos usar outra coisa chamada Future builder que permite de uma forma muito mais simples fazer tudo aquilo que fizemos atÃ© agora o feature builder para comeÃ§ar Ã© um widget e por isso eu vou fazer um Wap de aquilo que quero que seja refrescado Com base no future num Future builder em vez de um child eu vou colocar um builder e isto vai receber dois parÃ¢metros um Ã© o contexto que nÃ³s nÃ£o vamos precisar outro Ã© o SnapShot que vai ser muito importante eu jÃ¡ vou explicar porquÃª depois colocamos isto tudo aqui num return e para jÃ¡ o que temos Ã© que o builder retorna sempre a mesma coisa jÃ¡ lÃ¡ vamos Mas alÃ©m disso O feature builder recebe dois parÃ¢metros essenciais alÃ©m do builder ele tem que receber um feature e o feature Ã© simplesmente uma chamada uma funÃ§Ã£o que retorna um Future ou um objeto do tipo feature neste caso Ã© este jÃ¡ sabemos que isto retorna um Future Character e portanto nÃ³s vamos colocar isto aqui E deixamos de chamar aqui que era o grande problema que nÃ³s comeÃ§amos por resolver entÃ£o como o que Ã© que vai acontecer aqui este Future builder quando Ã© criado vai comeÃ§ar por chamar este Future e depois este builder Ã© chamado Ã  medida que o SnapShot vai mudando o que que Ã© isto o SnapShot deixa mostrar-vos aqui novamente este diagrama se bem se lembra o fature comeÃ§a a por estar em curso e depois pode ficar completo sendo que se ficar completo pode ser por ter tido sucesso ou por ter tido um erro o SnapShot Ã© uma variÃ¡vel que o feature builder cria e que tem uma propriedade chamada Connection state que em particular pode estar Waiting enquanto ele estÃ¡ em curso ou done quando ele fica completo Uma Vez ficando completo Eu a seguir posso ir ao SnapShot P as data ver se ele tem dados nesse caso correu bem ou fazer um SnapShot as error e ver se ele tem lÃ¡ um error nesse caso quer dizer que correu mal este data que aqui estÃ¡ Ã© exatamente o objeto que nÃ³s queremos obter do Servidor neste caso vai ser OAC dito isto vamos entÃ£o desenhar coisas diferentes consoante o que estÃ¡ no SnapShot para comeÃ§ar vou fazer aqui um refactoring e Vou extrair isto para um mÃ©todo chamado build Character e vou lhe colocar aqui isto como parÃ¢metro e como Ã© boa prÃ¡tica vou transformar isto num widget e nÃ³s aqui falta-nos aqui passar o Car mas jÃ¡ lÃ¡ vamos Ok vamos entÃ£o ver os vÃ¡rios estados que o SnapShot pode tomar primeira coisa Ã© ver o Connection state dele que pode ser o Waiting ou Dan hÃ¡ outros tipos Portanto o mais simples Ã© nÃ³s verificarmos se ele for diferente de Dan EntÃ£o vamos assumir que Ã© como se fosse Waiting e portanto Isto Ã© o nosso Waiting caso contrÃ¡rio entramos aqui em dois casos se o SnapShot tiver erros entÃ£o mostra erro else return build Character e neste caso Ã© o SnapShot pdata agora o que Ã© que a gente pode fazer aqui no Waiting em vez de colocarmos os nulos que era o que Aprecia antes vamos retornar um circular Progress indicator que Ã© aquele widget da rodinha a rodar aquele cÃ­rculo a rodar enquanto estÃ¡ a pensar e aqui podemos tambÃ©m retornar simplesmente um texto tex um texto com uma mensagem de erro genÃ©rica vamos vamos aqui experimentar parece est est tudo a funcionar a gente nÃ£o nÃ£o tÃ¡ a conseguir ver a rodinha Mas vamos simular a rodinha indo aqui ao repositÃ³rio e aqui no inÃ­cio do get Character fazer aqui um delay um feature p delay com uma duraÃ§Ã£o por exemplo de 2 segundos vamos esperar 2 segundos e a seguir Ã© que vamos ao servidor portanto Isto vai impor 2 segundos em cima do que ele jÃ¡ demora a ir ao servidor e reparem que eu fiz save ele automaticamente jÃ¡ se vÃª aqui em AÃ§Ã£o cÃ¡ estÃ¡ a rodinha e se houver um erro por alguma razÃ£o ele tambÃ©m vai mostrar o erro que era uma coisa que nÃ£o tÃ­nhamos antes portanto Ã© importante nestas chamadas assÃ­ncronas tratar sempre os trÃªs casos o caso de sucesso o caso enquanto estÃ¡ a pensar e o caso de erro jÃ¡ agora como Ã© que ele sabe como Ã© que o SnapShot sabe que ocorreu um erro Ã© quando lanÃ§amos uma exceÃ§Ã£o no repositÃ³rio Ok portanto este lanÃ§ar uma exceÃ§Ã£o vai originar que o SnapShot vai considerar que tem um erro e no erro vamos poder obter esta exceÃ§Ã£o que aqui estÃ¡ a mesma tÃ©cnica ao characters list page TambÃ©m passamos a usar um fature builder e e cÃ¡ estÃ¡ o Connection state diferente de dano o s error e o outro com o data eh aqui o botÃ£o passou a ter um comportamento diferente coisa que ele faz Ã© dizer que o Button press Ã© true e nesse caso ele usa isso para dizer se vai mostrar o build get characters Button ou se aplica o Future builder fazendo entÃ£o um resumo o que Ã© que precisamos para que a aplicaÃ§Ã£o passe a usar uma API externa devemos colocar para jÃ¡ no repositÃ³rio as nossas funÃ§Ãµes que vÃ£o ao servidor elas devem ser assÃ­ncronas devem retornar futures por causa disso e devemos tratar sempre o cÃ³digo o status code que vem do Servidor verificar se vem 200 ou vem outro e no caso de vir outro lanÃ§ar uma Exception devemos tambÃ©m implementar este mÃ©todo nos nossos modelos este from map que permite transformar Jason num num objeto do desse modelo uma vez feito isso a nÃ­vel de interface grÃ¡fica devemos usar o Future builder em que aqui chamamos os no future chamamos os mÃ©todos que estÃ£o no repositÃ³rio e neste Esta funÃ§Ã£o e neste parÃ¢metro builder atravÃ©s do SnapShot tratamos os trÃªs casos possÃ­veis ou mostramos uma circular Progress indicator caso ela esteja Waiting mostramos um erro Caso haja um erro ou entÃ£o mostramos o ecrÃ£ propriamente dito partindo do SnapShot pdata porque para chegar a este ponto Ã© porque de certeza que existem dados no SnapShot para terminar devem verificar se nÃ£o estÃ£o a fazer chamadas necessÃ¡rias ao servidor demasiadas chamadas em vez de fazerem sÃ³ uma Se for esse o caso ponderem passar a chamada Ã s funÃ§Ãµes do repositÃ³rio para dentro da funÃ§Ã£o init State
