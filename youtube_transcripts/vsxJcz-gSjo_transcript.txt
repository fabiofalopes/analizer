Neste vÃ­deo vou finalmente explicar como Ã© que se implementa o modo offline Isto vai tirar partir daquilo que temos vindo a construir atÃ© agora vou lembrar que ficamos neste ponto no Ãºltimo vÃ­deo temos uma classe abstrata repositÃ³rio que hoje vamos perceber exatamente para que Ã© que vai servir que Ã© Estendida ou implementada pelo lotr Services que trata da parte de ir api e a parte do lotr Database trata de ir Ã  base de dados local ambas falam a mesma linguagem no sentido em que transportam objetos do tipo Character E agora o que nÃ³s queremos Ã© ter este comportamento quando fazemos o get Character is Ã© o normal e vamos buscar ao servidor um Jason nÃ³s vamos passar a guardar isso na base de dados de forma a que se a ligaÃ§Ã£o se perder nÃ³s passamos a obter essa informaÃ§Ã£o a partir da base de dados a arquitetura perfeita para fazer isto Ã© aquilo que se chama arquitetura do repositÃ³rio ou padrÃ£o repositÃ³rio que eu passo a explicar o repositÃ³rio Ã© uma classe que abstr a fonte de dados temos aqui duas fontes de dados uma que vem de uma API remota outra que vem de uma base de dados local e se nÃ³s implementarmos isto de tal forma que quem chama deste lado nÃ£o sabe se estÃ¡ a ir ao lado remoto ou ao lado local EntÃ£o temos o modo offline e o modo online muito facilmente implementados sen nÃ£o vejamos quando eu estou online o que este repositÃ³rio vai fazer Ã© agulhar os pedidos que chegam aqui para o lado remoto mas se eu estou offline ele passa a agulhar para o lado local da B base de dados e para implementarmos isto nÃ³s vamos ter que criar entÃ£o um Cars repositÃ³rio finalmente o nosso repositÃ³rio que vai tambÃ©m ele estender esta classe abstrata reparem que tem cÃ¡ as quatro funÃ§Ãµes que estas jÃ¡ tinham mas agora estas funÃ§Ãµes vÃ£o ser inteligentes elas vÃ£o tirar partir destas duas variÃ¡veis que aqui estÃ£o uma a ponta para o remoto que vai ser o lotr Services outra a ponta para o local que vai ser o lotr Database e ela vai agulhar com sÃ£o eu estou online ou offline para um lado ou para o outro a antes de avanÃ§armos para essa classe sÃ³ lembrar que NÃ³s jÃ¡ tÃ­nhamos aqui uma espÃ©cie de agulhamento implementado aqui esta linha se repararem ela jÃ¡ estÃ¡ a agulhar se a source Ã© Network ela ia ao Services get characters se nÃ£o EA ao Database get characters e tambÃ©m aqui no detail tÃ­nhamos exatamente a mesma coisa o que nÃ³s agora vamos fazer Ã© passar esta lÃ³gica para dentro da tal classe repositÃ³rio e aqui nÃ³s passamos a chamar o repositÃ³rio e ele vai perceber onde ir buscar ou seja fica ido da interface grÃ¡fica se ele tÃ¡ ir buscar Ã  rede a api ou se estÃ¡ ir buscar a base de dados a primeira coisa que nÃ³s vamos ter que fazer Ã© perceber se estamos online ou offline para isso eu vou criar aqui uma classe nova aliÃ¡s atÃ© vou criar uma pasta nova chamada Services e aqui dentro vou criar um connectivity service que vai ser simplesmente uma classe connectivity service que vai ter uma funÃ§Ã£o muito simples torna um Bull e diz is online se neste momento estamos online ou nÃ£o para conseguirmos fazer isto vamos ter que usar uma biblioteca que permite saber o estado da conectividade que vai vamos acrescentÃ¡-la aqui ao pubspec que Ã© o connectivity Plus nÃ£o esqueca de fazer pubg e agora vou voltar aqui ao connectivity service vou tirar a partir dessa biblioteca para criar aqui este connectivity vem do connectivity Plus este check connectivity vai-me dar uma variÃ¡vel que me diz qual Ã© a conectividade que existe neste momento ela pode ser pode nÃ£o existir pode ser mobile ou pode ser wi-fi eu neste caso quero que ela retorne true se a conectividade for mobile ou wi-fi temos aqui um problema que Ã© o check connectivity ela nÃ£o retorna um uma conectividade ela retorna um Future connectivity Porque isto Ã© uma coisa que pode demorar algum tempo a perceber esta conectividade Ã© uma funÃ§Ã£o assÃ­ncrona portanto e sendo isto uma funÃ§Ã£o assÃ­ncrona se calhar Ã© uma boa ideia eu colocar aqui um mas se eu colocar esta wait jÃ¡ sabemos o que Ã© que falta aqui nÃ£o Ã© a funÃ§Ã£o tem que ser assÃ­ncrona e se a funÃ§Ã£o tem que ser assÃ­ncrona entÃ£o ela tem que retornar um Future Bull Agora sim temos criado o nosso serviÃ§o vamos usÃ¡-lo para identificar se estamos online ou offline prÃ³ximo passo Ã© entÃ£o implementar o characters repository eu vou pegar nesta classe que jÃ¡ tem os cabeÃ§os que eu tenho que implementar ela basicamente vai ter que estender isto e portanto atÃ© o mais simples Ã© fazer aqui um copy para characters repository Deixa de ser abstrato e para jÃ¡ vou meter vou meter aqui corpo vazio em cada uma delas claro que elas estÃ£o a caixar porque eu nÃ£o estou a retornar nada elas vÃ£o ter que ser assÃ­ncronas todas e agora o que Ã© que esta classe vai ter que saber vai ter que saber qual Ã© o local e qual Ã© o Remote vou ter que ter aqui uma variÃ¡vel I Character repository que Ã© local e uma que Ã© remote e tambÃ©m vou ter que ter Isto vai ser bom para garantir aqui uma boa injeÃ§Ã£o de dependÃªncias aqui o connectivity service eu nÃ£o quero instanciar dentro desta classe o connectivity service eu quero recebÃª-lo e por isso eu quero guardÃ¡-lo numa variÃ¡vel vou criar aqui um gerar aqui um Construtor eu vou colocar este Construtor como named ou seja vou poder pÃ´r local igual a isto remote igual a isto e connective service igual a isto para ficar mais claro o que Ã© que estÃ¡ a acontecer ele tÃ¡-se a caixar porque faltam os required primeira coisa que eu vou querer fazer Ã© verificar o estado da conectividade Logo no inÃ­cio sempre que eu vou chamar uma funÃ§Ã£o destas eu vou verificar se estou online ou se estou offline e isso Ã© tÃ£o simples como fazer isto eu tenho que usar este aight por causa disto ser assÃ­ncrono Ou seja eu tenho que ficar Ã  espera que ele me diga se estÃ¡ online ou offline nÃ£o hÃ¡ problema porque a prÃ³pria funÃ§Ã£o getc jÃ¡ era assÃ­ncrona e agora se tiver online o que ele vai fazer Ã© retornar o Remote pget Character Caso contrÃ¡rio vai retornar o local pget characters Ok super simples como eu vos disse o difÃ­cil Ã© preparar isto para este padrÃ£o porque uma vez preparando Ã© muito fÃ¡cil implementar aqui a classe reposit agora vou fazer o mesmo para esta classe aqui vai ser ID aqui a mesma coisa estÃ£o a ver super simples e agora estas estas duas funÃ§Ãµes tÃªm aqui um problema lembrem-se que isto Abstrai a fonte de dados que estÃ¡ por trÃ¡s uma uma das fontes de dados permite inserir personagens mas a outra nÃ£o a api nÃ£o permite inserir personagens NÃ³s jÃ¡ tÃ­nhamos visto isso Se nÃ³s formos aqui ao lotr Services quando eu vou aqui ao insert e ao delete elas nÃ£o funcionam porque eu api a api Ã© read only Ã© sÃ³ de leitura e portanto eu nÃ£o consigo lÃ¡ alterar dados e Ã© isso que a gente vai querer fazer aqui tambÃ©m o que a gente vai fazer Ã© ser mais drÃ¡sticos e dizer simplesmente nÃ£o Ã© possÃ­vel chamar o insert e o delete All tal como jÃ¡ acontecia no lotr Services se calhar aqui eu vou pÃ´r Not implemented nÃ£o Ã© bem Ã© not available ou seja nÃ£o estÃ¡ disponÃ­vel este serviÃ§o no repositÃ³rio genÃ©rico Se quiserem OK agora que tenho o meu agora que tenho o meu repositÃ³rio eh falta-me alterar a injeÃ§Ã£o de dependÃªncias enquanto que eu aqui estava a injetar diretamente o serviÃ§o remoto e o serviÃ§o local Eu agora vou querer injetar eu atÃ© posso deixar estes Ã  mesma nunca sabe se serÃ£o necessÃ¡rios ou nÃ£o eu agora atÃ© posso injetar aqui um characters repository mas antes disso eu vou extrair isto para uma variÃ¡vel jÃ¡ vÃ£o perceber PorquÃª eles extraÃ­am mas poss Ito errado nÃ£o Ã© aqui que eu quero esta variÃ¡vel Ã© aqui mesmo fora do Mine e vou dizer que Ã© um final vou fazer o mesmo com o Database e agora aqui vou usar a variÃ¡vel em vez da chamada a funÃ§Ã£o isto jÃ¡ tÃ¡ como expressÃ£o esta tambÃ©m vou colocar como expressÃ£o Ok Isto Ã© exatamente o que estava antes mas agora guardei primeiro aqui as variÃ¡veis antes de providenciar aqui no multiprovider vou criar entÃ£o agora um novo provider chamado para extrair um Cars repository e que ele basicamente o que vai fazer Ã© criar um characters repository que ele agora recebe estes parÃ¢metros o que Ã© que Ã© o local Ã© o lotr Database o Remote Ã© o lotr Services e o connectivity service nÃ£o o temos e mas eu vou criÃ¡-lo agora aqui podia tambÃ©m usar uma variÃ¡vel para ele mas essa nÃ£o nÃ£o tem grande valor neste momento vou para jÃ¡ deixar assim se for preciso depois cria uma variÃ¡vel e agora ao alterar isto eu tenho que agora refletir isso em todos os sÃ­tios onde eu usava o provider Ou seja eu agora aqui vou deixar de ter estes dois objetos diferentes vou passar a ter um Ãºnico o qual interajo que vai ser o repositÃ³rio precisamente e isto passa a ser quero ter repositÃ³rio deixo de precisar da base de dados ela tÃ¡ escondida eu nÃ£o sei o que Ã© que estÃ¡ por trÃ¡s eu para jÃ¡ como deixei de querer interagir com a base de dados eu vou retirar daqui estes botÃµes nÃ£o me interessam porque agora basicamente o que eu vou querer Ã© ter sempre sÃ³ o get characters do Network ele se estiver online obtÃ©m do da rede Se tiver offline ou vai opter da base de dados automaticamente ou seja isto na realidade Deixa de ser from Network Button Ã© get characters vou alterar tambÃ©m aqui nÃ£o interessa de onde Ã© que Ã© eu quero apenas obter os personagens da fonte que tiver disponÃ­vel nesse momento tenho entÃ£o o meu repositÃ³rio e agora este esta linha desaparece eu deixo de fazer o agulhamento aqui deixa de ser Services para passar a ser reposit e isto desaparece tambÃ©m daqui no detail Aqui passa a ser o repositÃ³rio aqui tambÃ©m e Retiro dai porquÃª porque aquele agulhamento agora Ã© feito aqui dentro Pronto passei a ter aqui apenas um botÃ£o Gets que vai tratar toda esta lÃ³gica se estÃ¡ online vai Ã  rede Se estÃ¡ offline vai Ã  base de dados falta-me acrescentar aqui um await nisto Porque isto sÃ£o funÃ§Ãµes assÃ­ncronas vamos agora testar portanto cÃ¡ estÃ¡ chamada api obteve Ok como estou online ele basicamente tÃ¡ sempre para agulhar para o Remote agora Vamos experimentar pÃ´r isto offline estamos offline estamos em modo aviÃ£o vamos tentar chamar o get carters ele nÃ£o tenta chamar o servidor mas nÃ£o aparece nada nÃ³s estamos quando estamos online ele obtÃ©m do remote data source quando estamos offline ele obtÃ©m do local data source mas Ã© preciso que hajam dados aqui na basados para retornar o que estÃ¡ a faltar Ã© nÃ³s prepararmo-nos em online para o momento em que vamos estar offline e o que Ã© que Ã© prepararmos Ã pegar noos dados que vieram da Api enviÃ¡-los para a base de dados de forma a que da prÃ³xima vez se por acaso estivermos offline possamos ir buscÃ¡-los Ã  base de dados ou seja tÃ¡ faltar estes dados terem enviados para a base de dados EntÃ£o Ã© isso que vamos acrescentar aqui aqui o que vamos ter que fazer Ã© basicamente meter isto numa variÃ¡vel V chamar Cars E no meio da obtenÃ§Ã£o dos personagens e e antes dos retornarmos NÃ³s vamos guardÃ¡-los na base de dados como Ã© que a gente os vai guardar nÃ³s podemos ter aqui um sistema inteligente em que ha ver que personagens Ã© que modificaram no servidor em relaÃ§Ã£o aos que estÃ£o na base de dados nÃ³s aqui vamos ser mais simples vamos simplesmente apagar tudo o que estÃ¡ na base de dados e voltar a colocar lado cada vez que obtemos uma listagem do Servidor vamos comeÃ§ar por chamar local delete All jÃ¡ sabemos que tem que ser no local nÃ© NÃ£o pode ser no remote e agora vamos fazer um ciclo em que basicamente percorremos os personagens que foram obtidos a partir da api e para cada um vamos chamar o local P insert Car tÃ£o simples como isto hÃ¡ aqui sÃ³ um pormenor que Ã© estas funÃ§Ãµes quer o delete All quer o insert sÃ£o funÃ§Ãµes assÃ­ncronas o quer dizer que ele nÃ£o vai prender a execussÃ£o aqui neste momento o quer dizer que ele pode comeÃ§ar inserir personagens quando o delol ainda nÃ£o acabou eu podia fazer aqui um await para eliminar esse problema mas isso significava que eu ia prender tambÃ©m o prÃ³prio get characters e na realidade eu nÃ£o preciso de prender eu nÃ£o quero que a escrita e na base de dados ou as operaÃ§Ãµes com a base de dados interfiram no desempenho desta funÃ§Ã£o o que Ã© que Ã© esta funÃ§Ã£o vÃ¡ buscar ao servidor os dados a seguir fique assincronamente a escrevÃª-los na base de dados mas retorne logo o que tem sem ficar Ã  espera que isso acabe entÃ£o para isso o que eu vou fazer Ã© garantir apenas que isto Ã© executado assincronamente e nÃ£o interfere com isto mas que isto Ã© executado depois disto as funÃ§Ãµes assÃ­ncronas que Retornam futures tÃªm uma funÃ§Ã£o chamada den que recebem aqui um parÃ¢metro que nÃ£o me interessa portanto posso pÃ´r aqui um und e agora passo aqui para dentro isto e portanto o que isto vai acontecer Ã© assincronamente ele vai fazer fazer o delol depois quando o delol acabar vai inserir para cada um dos personagens mas isto vai correr jÃ¡ isto retornou estÃ£o a ver ele vai basicamente nÃ£o vai ficar preso aqui nÃ£o hÃ¡ aqui nenhum ait ele retorna logo os personagens e ali em paralelo vai eh introduzindo na na base de dados eu poderia fazer o mesmo aqui mas dado que esta listagem jÃ¡ me obtÃ©m os dados todos que eu preciso dos personagens eu nÃ£o faz sentido eu aqui estar preocupado com isto Ou seja eu jÃ¡ tenho a base de dados toda preenchida cada vez que faÃ§o um get Character de ID eu jÃ¡ tenho isso na base de dados portanto nÃ£o vale a pena estar aqui a complicar isto eu vou deixar desta forma e agora podemos arrancar novamente agora vou fazer aqui uma coisa que Ã© para vermos isto acontecer vou abrir aqui a base de dados vou sÃ³ fazer aqui um refresh ok temos a base de dados vazia agora reparem vou aqui colocar aqui para vermos a chamada api ok obteve e agora vamos aqui fazer um refresh e cÃ¡ estÃ£o todos os dados que estavam no servidor estÃ£o agora tambÃ©m na base de dados O que quer dizer que eu agora posso fazer gob posso mudar isto para offline novamente e reparem que eu estou a obter os dados e atÃ© podemos aqui verificar que ele nÃ£o estÃ¡ a ir ao servidor ele nÃ£o tÃ¡ a escrever aqui este get ou seja ele estÃ¡ a obter os dados localmente portanto temos basicamente o modo offline implementado em resumo o que Ã© que Ã© necessÃ¡rio para implementar o modo offline primeiro criar uma classe abstrata que tenha as funÃ§Ãµes todas da api mais uma forma de inserir e apagar objetos na base de dados para o momento em que temos que sincronizar aquilo que vem da api com aquilo que estÃ¡ na base de dados criar no fundo uma rÃ©plica local depois vamos ter que ter uma classe que estende essa esse repositÃ³rio e que implementa a lÃ³gica da base de dados outra que implementa a lÃ³gica dos Web Services com api Finalmente um Car repository que Com base no estado da conectividade ora vai ao remote ora vai ao local sendo que quando vai ao remote e consegue ter sucesso deve apagar o que estÃ¡ na base de dados e inserir os valores que vÃª do da api isto tudo po vos parecer um bocado desnecessÃ¡rio vÃ£o ver que quando fizermos testes vai dar imenso jeito a gente podermos incluir aqui os nossos prÃ³ prÃ³prios serviÃ§os a base de dados e o prÃ³prio connectivity service a gente controlar o connectivity Service
