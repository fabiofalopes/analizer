Neste vÃ­deo vamos continuar a melhorar o nosso Lord of the Rings para passar a ter uma base de dados local podemos aver aqui dois botÃµes novos um que permite obter os personagens a partir de uma base de dados local e outro que permite inserir personagens novos Ora bem voltei ao inÃ­cio do Ãºltimo episÃ³dio onde tÃ­nhamos apenas isto cop tinha os personagens a partir da rede a partir da Api para comeÃ§armos entÃ£o a criar a partir desse ponto a nossa base de dados a base de dados que vamos usar Ã© uma base de dados chamada sequel Lite que existem todos os telemÃ³veis seja iOS seja Android vem incluÃ­da nÃ£o precisamos de instalar nada no entanto para aceder a ela vai nos dar jeito aqui um uma biblioteca que Ã© esta SKF FL uma vez essa biblioteca nÃ£o se esqueÃ§am de fazer pubg vamos criar aqui um novo package chamado data e um ficheiro chamado lotr Database que lÃ¡ dentro Vamos criar um lotr Database e Ã© aqui dentro que vamos usar uma classe do SKF Lite que Ã© este Database cÃ¡ estÃ¡ Vamos colocar nullable ela no inÃ­cio vai estar a n e vamos criar um mÃ©todo init para inicializar porque Ã© que nÃ£o inicializam Logo no Construtor ou seja neste caso no Dart nÃ£o hÃ¡ New Mas podÃ­amos logo criar uma InstÃ¢ncia de lotr Database e elee instanci Ava logo esta Database porque a inicializaÃ§Ã£o desta base de dados vai ser assincrona ela vai demorar algum tempo porque nÃ³s nÃ£o sÃ³ temos que nos conectar a essa base de dados como temos que criar a prÃ³pria base de dados da primeira vez isso pode demorar algum tempo e portanto vai ter que ser feito de forma assÃ­ncrona uma vez que vai ser feito de forma assÃ­ncrona vamos usar um esquema parecido com aquele que jÃ¡ tÃ­nhamos usado no repositÃ³rio nÃ£o sei se se lembram em que temos mÃ©todos funÃ§Ãµes assÃ­ncronas que Retornam futures entÃ£o neste caso vou entÃ£o criar aqui uma funÃ§Ã£o que retorna um Future eu vou pÃ´r Future void porque em princÃ­pio esta inicializaÃ§Ã£o vai sempre correr bem portanto nÃ£o precisamos de retornar nada e aqui dentro Eu vou jÃ¡ colocar o cÃ³digo que vai inicializar a base de dados pronto copiei para aqui este cÃ³digo vou agora explicar Ele Ã© bastante simples temos aqui uma funÃ§Ã£o que vem no package SKF FL que permite abrir uma base de dados que comeÃ§a por receber o sÃ­tio onde Vamos guardar a base de dados neste caso Ã© o ficheiro onde Vamos guardar a base de dados reparem que este ficheiro Ã© o nome que vocÃªs quiserem dar e isto obtÃ©m o caminho dentro do file System do dispositivo para a base de dados apropriado Isto Ã© dependente do sistema operativo no caso do iOS vai colocar num sÃ­tio no caso do Android vai colocar no outro mas ele trata disso automaticamente e depois temos aqui uma callback que Ã© chamada apÃ³s a base de dados tem sido criada ele chama esta callback que Ã© o momento em que nÃ³s vamos aproveitar Olha a base de dados foi criada vou criar as tabelas todas eu aqui sÃ³ tenho uma mas posso criar vÃ¡rias tabelas que onde vou querer guardar os meus dados neste caso Isto Ã© SQL puro Create table Character Ok temos um ID que Ã© o primary Key temos os outros atributos que jÃ¡ tÃ­nhamos visto antes no Character e o name Ã© not nul mas os outros sÃ£o nul eu vou guardar o gender como integer um no caso de ser homem e zero no caso sem mulher temos tambÃ©m Ã© uma boa ideia ter esta versÃ£o aqui nÃ£o vÃ¡ nÃ³s queremos mais estar de evoluir a base de dados Imaginem que a aplicaÃ§Ã£o jÃ¡ estÃ¡ instalada Quero manter os dados que lÃ¡ estÃ£o mas de alguma forma quero acrescentar Novos Campos novas tabelas etc esta versÃ£o vai dar jeit para isso e agora podemos chamar Esta funÃ§Ã£o init no Main ou seja logo quando a aplicaÃ§Ã£o arranca nÃ³s DevÃ­amos logo conectarnos Ã  base de dados verif se estÃ£o as tabelas criadas ou nÃ£o se nÃ£o tiverem cria as tabelas isto sÃ³ vai acontecer da primeira vez porque uma vez que a Bas esteja criada o Create jÃ¡ nÃ£o Ã© chamado atenÃ§Ã£o isto jÃ¡ sÃ³ Ã© chamado quando eu crii base dados pela primeira vez e agora aqui nÃ³s vamos criar entÃ£o este esta base de dados a primeira coisa que a gente vai fazer Ã© Vamos alterar este provider para passar a ser um multiprovider nÃ³s vamos aqui querer ter vÃ¡rios objetos que vamos querer passar aos widgets nÃ£o Ã© sÃ³ jÃ¡ o Carter repositÃ³rio e portanto convÃ©m ter aquilo que se chama multiprovider no caso do multiprovider Eu jÃ¡ nÃ£o tenho um Create ten Ã© uma lista de providers e cada um deles vai ter um Create e eu vou criar um objeto provider e lÃ¡ dentro passo isto que jÃ¡ aqui estava mas agora posso ter vÃ¡rios Esta Ã© a grande vantagem jÃ¡ agora convÃ©m aqui fazer isto isto poderÃ¡ dar jeito nos testes se nÃ³s por alguma razÃ£o quisermos injetar aqui objetos fake fake characters repository entÃ£o dÃ¡ jeito eu ter aqui este tipo neste provider faÃ§am desta maneira mesmo que nÃ£o dÃª erros de compilaÃ§Ã£o EntÃ£o vamos acrescentar aqui pronto Isto Ã© como digamos exatamente o que jÃ¡ estava antes mas agora jÃ¡ preparado para ter vÃ¡rios providers Qual Ã© o prÃ³ximo provider que eu aqui quero Ã© precisamente o lotr Database eu podia ter feito isto como um singleton mas uma vez que estamos nesta arquitetura de providers eu nÃ£o quero ter singletons quero ter isto tudo com provider que Ã© para eu depois nos testes poder injetar a minha prÃ³pria base de dados entÃ£o vamos aqui mudar isto para aliot Database Ok o que isto significa entÃ£o Ã© que eu agora dentro a partir do contexto em qualquer widget da minha aplicaÃ§Ã£o posso obter quer um Cars repositÃ³rio quer um lotr Database e vai ser jÃ¡ aqui precisamente no myap que eu vou querer jÃ¡ aceder ao lotr Database para isso eu vou ter que fazer aqui uma coisa que Ã© uma vez que isto Ã© sÃ­ncrono e pode demorar algum tempo eu jÃ¡ nÃ£o posso simplesmente abrir a aplicaÃ§Ã£o e mostrar logo o characters list page eu vou ter que chamar uma coisa que vai retornar um Future eu vou ter que esperar que esse Future termine estou a falar do init ou vou esperar que isto termine Imaginem que isto demora alguns segundos e sÃ³ nessa altura Ã© que eu vou poder eh mostrar entÃ£o este Cars list page entÃ£o para isso vamos usar aquilo que jÃ¡ tÃ­nhamos usado no car's list page que Ã© um Future builder em que eu vou basicamente para quem nÃ£o se lembra registrar um Future e um builder este Future vai ser uma funÃ§Ã£o que retorna um Future e este builder vai ser chamado Ã  medida que esse Future vai evoluindo do Connection state Waiting para o Connection state done portanto a primeira coisa que eu vou ter que fazer uma vez que esta este ecrÃ£ vai ter que mudar apÃ³s acontecer alguma coisa ou seja ele vai comeÃ§ar por mostrar aqui uma rodinha e depois essa altura mostra este ecrÃ£ que aqui estÃ¡ entÃ£o eu como vou ter que mudar o ecrÃ£ eu vou transformar isto num stateful widget nÃ£o pode ser um stateless widget porque cator eu vou ter que chamar o set state para que ele se refresque a seguir vou querer obter aqui logo a seguir aqui ao build vou querer obter a minha Database chamar assim jÃ¡ sabem como Ã© que eu obtenho a partir do contexto faÃ§o um read e aqui coloco o que quero obter neste caso Ã© um Database pronto Isto vai ser exatamente o que foi passado aqui mas no caso por exemplo de ser um teste vai ser pode ser outra coisa que nÃ£o esta que vem daqui do runup agora vou entÃ£o encapsular este material app num Future builder que jÃ¡ sabemos que nÃ£o tem nada disto tem um Future que neste caso vai ser o init do Database e tem um builder e tudo o resto que estÃ¡ lÃ¡ dentro Ã© aquilo que jÃ¡ estava mas agora nÃ³s vamos olhar para este SnapShot para perceber se jÃ¡ podemos mostrar Isto ou nÃ£o ora Podemos fazer aqui um verificar se o s Connection state do SnapShot Ã© done EntÃ£o vamos mostrar isto que era o que jÃ¡ estava caso contrÃ¡rio Vamos mostrar apenas uma circular Progress indicator aqui centrada e o material up apenas com isto mais nada nem tÃ­tulo nem coisa nenhuma apenas Isto vai ser sÃ³ durante um bocadinho enquanto ele estÃ¡ a carregar a base de dados das vezes seguintes atÃ© vai ser mais rÃ¡pido jÃ¡ tÃ¡ base de dados criada e portanto Isto vai ser relativamente rÃ¡pido mas assim temos a certeza que isto estÃ¡ a reagir bem ao assincronismo relacionado com este lotr Database init podemos jÃ¡ testar isto Ok nem sequer Conseguimos ver aqui nada eu vou fazer novamente ok Isto Ã© tal maneira rÃ¡pido de facto a ligaÃ§Ã£o Ã  base de dados e a criaÃ§Ã£o que nÃ£o vemos nada mas mesmo assim Ã© uma boa ideia fazer desta forma Se tiverem vÃ¡rias tabelas e Se tiverem carregar muitos dados para a base de dados Ã© uma boa ideia terem este circular Progress indicator aqui enquanto ele estÃ¡ a pensar EntÃ£o como Ã© que eu sei que esta base de dados jÃ¡ foi criada na realidade o Android studo permite ver o conteÃºdo da base de dados da base de dados cqu Lite atravÃ©s deste App inspe que tÃ¡ aqui se por acaso nÃ£o vos aparecer isto venham aqui ver se ele nÃ£o estarÃ¡ por aqui e quando carregam no app inspection aparece vos aqui o emulador vocÃªs tÃªm que vir aqui escolher a aplicaÃ§Ã£o que nÃ£o tÃ¡ DIT T Ele demora um bocadinho esperem um bocadinho e ele eventualmente vai entÃ£o aparecer aqui este Database inspector conseguem ver que foi criado aqui um ficheiro lot RDB que lÃ¡ dentro tem uma tabela Carter Com estes estas colunas portanto ela neste momento tÃ¡ vazia mas tem o conteÃºdo que a gente quis para ele entÃ£o agora que temos a base de dados criada podemos comeÃ§ar a implementar a inserÃ§Ã£o e a obtenÃ§Ã£o de dados a partir da base de dados vamos comeÃ§ar pela pela obtenÃ§Ã£o de dados para isso vamos comeÃ§ar por olhar aqui para o modelo e lembrar que isto Ã© aquilo que representa um personagem em memÃ³ria Ok Isto Ã© agnÃ³stico daquilo de onde vem ou seja independentemente disto vir de uma API de vir da base B dados do que Ã© que a gente tenha como fonte de informaÃ§Ã£o nÃ³s definimos que cada personagem tem estes Campos este isto at tÃ¡ fora de ordem eu acho que isto prefiro isto aqui ok jÃ¡ agora pronto reorganizei isto mas basicamente Isto Ã© aquilo que me interessa a mim programador independentemente da fonte de informaÃ§Ã£o por acaso aqui tenho este from map que deu imenso jeito nÃ£o sei se lembram para obter a partir do Jason que vinha da api criar um objeto do tipo Character Com base no que vinha no Jason este map que aqui estÃ¡ era obtido a partir do Jason que era aqui no Character repositÃ³rio eu obtinha uma lista por exemplo de characters e a segui fazia este from map ou entÃ£o aqui diretamente neste get Carter tambÃ©m fazia aqui um from map entÃ£o este from map na altura fez sentido mas agora eu vou querer obter o meu Character de dois sÃ­tios diferentes duas fontes de informaÃ§Ã£o diferente Ou ela vem da api e nesse caso vem a par Jon ou ela vem a partir da base de dados e nesse cas o que a base dados me vai dar Ã© um map e portant eu para distinguir os dois vez que o J tamb Ã© map tamb map eu sealar vou criar aquiar aqui o nome fazer aqui um ref e mudar isto para from Jason e vou criar uma coisa parecida chada from DB ou seja from Jason vem da api from DB vem da base de dados aqui atÃ© vou eh mudar se calhar isto para ficar mais claro para Jason e este para DB pronto na DB por exemplo nÃ£o hÃ¡ este and score ID isto era uma coisa que era do Jason portanto eu vou deixar este assim outra coisa que acontece Ã© que o gender que a gente tem aqui Ã© uma string que nÃ£o sei se se lembram pode ser mail ou femail mas na base de dados nÃ³s resolvemos guardar isso deixem-me Recordar como integer em que 1 era Male e 0 era female ou seja vamos fazer essa transformaÃ§Ã£o aqui portanto se o que vem da base de dados Ã© um EntÃ£o nÃ³s vamos transformar isso em mail na base de dados estÃ¡ um aqui vai est mail no caso contrÃ¡rio vai ser F feito isto podemos vir aqui ao nosso lotr Database e criar um nova funÃ§Ã£o que tambÃ©m vai ter que ser um Future mas agora vai ser uma L Character get characters S isto Deve parecer familiar Porque nÃ³s jÃ¡ fizemos uma funÃ§Ã£o muito parecida com esta Se nÃ³s formos aqui ao repositÃ³rio temos precisamente aqui um Future list Character get characters a vamos deixar assim e o que isto vai fazer Ã© obter uma lista dos personagens que estÃ£o na baseados nÃ£o na AP para isso vamos usar o nosso Database a nossa variÃ¡vel Database mas temos aqui um problema Ã© que esta Database pode estar a nul nada me garante que alguÃ©m se lembrou de chamar este init comeÃ§ar por validar que o Database Ã© diferente de nulo porque se for nulo a gente vai logo a lanÃ§ar uma sÃ£o para indicar atenÃ§Ã£o que te esqueceste de inicializar a Database temos um mÃ©todo dentro do Database que nos permite correr queries fazer selects neste caso ou seja o que eu vou fazer Ã© um select as TR from Character para isso vou usar o rock query posso fazer este Database ponto exclamaÃ§Ã£o porque jÃ¡ verifiquei ali que ele nÃ£o Ã© nul E isto Ã© assÃ­ncrono logo devo fazer a um await a espera do resultado O resultado vai ser uma lista de Map e por isso o que eu vou fazer Ã© vou precisamente usar o map agora para outra coisa a funÃ§Ã£o map que jÃ¡ usei no car list Page para transformar cada uma das entradas desta lista que sÃ£o Maps que V da base de dados nos Maps nos Cars para isso Ã© que nÃ³s usamos aquele from DB precisamente para isso entÃ£o basta fazer desta forma ou seja para cada entrada que tÃ¡ nesta lista eu vou obter uma entry que Ã© um map que vai entrar dentro deste from DB que foi aquele que a gente criou a Pou cÃ¡ estÃ¡ e ele vai me criar uma lista de Cars mesmo com isto eu jÃ¡ posso obter aqui se calhar criar aqui o botÃ£o para obter os carters a partir da base de dados que Ã© isso que vamos fazer agora entÃ£o vamos comeÃ§ar aqui por transformar este botÃ£o que aqui tÃ¡ get characters from Network e agora vou mudar tambÃ©m aqui fazer aqui um refactor para build get CS from Network vou criar uma funÃ§Ã£o parecida que vai ser o from DB e aqui Ã© from Database isto atÃ© Ã© igual o Button press tÃ¡ igual a true Mas vamos ter que distinguir se eu carreguei num ou no outro entÃ£o para isso eu vou criar aqui uma nova variÃ¡vel que lhe vou chamar source que inicialmente vai estar a nul mas que nÃ³s vamos preenchÃª-la da forma correta como aqui vamos transformar isto em vez de ser uma expressÃ£o num bloco para podermos ter duas instruÃ§Ãµes e agora vamos dizer que a source neste caso foi Network e vamos fazer o mesmo aqui mas agora a source e DB Portanto o que Ã© que ganhamos com isto nÃ³s agora aqui vamos poder distinguir eh neste Future onde Ã© que nÃ³s queremos ir buscar os kotter Se queremos ir buscar ao repositÃ³rio ou Ã  base de dados mas antes disso eu tenho que mudar isto ele neste momento apenas mostra o get from Network Button eu vou transformar isto numa coluna de forma a que consiga colocar aqui o get characters from DB Button jÃ¡ agora deixa-me sÃ³ verificar aqui uma coisa eu acho que isto nÃ£o Ã© necessÃ¡rio a gente nÃ£o estÃ¡ a usar isto Portanto vamos Apagar corrir isto novamente ok temos este problema aqui jÃ¡ sabemos como resolver penso eu que jÃ¡ jÃ¡ sabem Isso Ã© sÃ³ chegar aqui Ã  coluna e dizer com o Main access alignment Ã© Center Vamos entÃ£o aqui usar no future se o Source for igual a Network EntÃ£o nÃ³s vamos dar aquilo que jÃ¡ tÃ­nhamos que era vai ao repositÃ³rio obter o characters caso contrÃ¡rio vamos ah nÃ£o temos a base de dados espera lÃ¡ precisamos aqui de obtÃª-la cÃ¡ estÃ¡ por injeÃ§Ã£o de dependÃªncias muito facilmente obtemos a base de dados e estÃ¡ ela e portanto vamos aqui chegar aqui e fazer Database ponto get characters Ok tÃ£o simples como isto portanto se a source for Network entÃ£o obtÃ©m da rede Se nÃ£o obtÃ©m da base de dados perfeito tudo o resto Ã© igual porque reparem que a lista que nÃ³s passamos para aqui jÃ¡ Ã© uma lista de Character characters quer Num caso quer n outro nÃ³s estamos a obter uma lista de characters portanto jÃ¡ temos objetos que jÃ¡ sÃ£o independentes quer da rede quer da base de dados EntÃ£o vamos ver se isto estÃ¡ a funcionar vamos obter os carteres da base de dados nÃ£o aparece nada agora temos aqui um problema que eu tambÃ©m quero resolver que Ã© nÃ£o temos maneira como Isto Ã© prÃ³pria pÃ¡gina Isto nÃ£o foi um p Isto Ã© a prÃ³pria pÃ¡gina que eu estou a mudar e agora nÃ£o tenho maneira de fazer back portanto Vamos alterar aqui esta lista para passar a ter aqui um botÃ£o back atÃ© ficam a saber como Ã© que podem acrescentar o vosso prÃ³prio botÃ£o back nesteo vamos aqui comeÃ§ar por colocar esta vista esta lista num widget chamado expanded agora vamos colocar isto num colum lÃ¡ dentro vai est este expanded mas antes disso vamos criar um elevated Button jÃ¡ lÃ¡ vamos cujo child vai ser um text go back Ok vamos ver portanto se eu agora fizer isto eu jÃ¡ ten um go o go ainda nÃ£o faz nada mas na realidade o que Ã© que Ã© o go neste caso vamos olhar para aqui e reparar que se o Button press tiver false os botÃµes para obter a lista Caso esteja a true EntÃ£o vai mostrar o resultado da source Ora se a gente meter o Button PR false ele automaticamente com set state Claro ele automaticamente vai passar a mostrar os botÃµes novamente Ã como se eu jÃ¡ nÃ£o tivesse carregado no botÃ£o entÃ£o novamente aqui cÃ¡ estÃ¡ ele a funcionar e tambÃ©m podemos ver se cÃ¡ estÃ¡ o Car tambÃ©m tem um gob porque a gente colocou isto no build list que Ã© usado pelos dois portanto os do as duas listas sÃ£o feitas exatamente da mesma forma isto era expectÃ¡vel nÃ£o temos nada na base de dados portanto tÃ¡ na altura de criarmos aqui um car na base de dados para isso vamos acrescentar aqui um novo botÃ£o build build insert Character que nÃ£o tem nada a ver com isto e que basicamente vai chamar o Database que nÃ³s ainda nÃ£o tem temos aqui vamos ter que lhe passar e que a gente vai basicamente Ness B fazer o insert nÃ³s ainda nÃ£o temos isso lÃ¡ vamos comeÃ§ar por criar aqui uma forma de inserir um personagem comeÃ§ar por criar aqui uma funÃ§Ã£o que tem que ser assÃ­ncrona mais uma vez que recebe um Character o tal modelo e e retorna um Future void neste caso o insert nÃ£o retorna nÃ£o hÃ¡ grande coisa para retornar e agora vou voltar a fazer esta validaÃ§Ã£o que aqui estÃ¡ isso tem que estar em todos e sÃ³ depois fazer esta validaÃ§Ã£o Ã© que eu vou entÃ£o Poder chamar o insert do Database Portanto o Database tem uma funÃ§Ã£o que me permite inserir na tabela Character um objeto desta forma e eu aqui tenho que receber um map com os dados que eu quero inserir e falta-me este to DB que ainda nÃ£o existe vamos criÃ¡-lo basicamente o que isto faz Ã© converter a informaÃ§Ã£o interna do num map que eu posso enviar para a base de dados Vamos criar um uma funÃ§Ã£o tb que retorna um map em que a chave Ã© string e o valor pode ser qualquer um pode ser inteiro string o quer que seja e por isso Ã© que pisemos aqui este dynamic isto basicamente vai retornar um map eh em que por exemplo o ID Ã© o ID desta classe Este Ã© fÃ¡cil o name Ã© o name desta desta classe estes dois sÃ£o os parÃ¢metros obrigatÃ³rios mas os outros podem ou nÃ£o estar preenchidos entÃ£o para evitar que que eu tenha dados a mais neste Jason nÃ£o Ã© que fizesse mal est lÃ¡ nulo eu podia pÃ´r por exemplo parce dois pontos nulo Mas para ficar melhor e eu vou fazer isto ou seja se o birth for diferente nulo entÃ£o Eu preencho isto senÃ£o nada nÃ£o acontece nada Ã© possÃ­vel fazer isto em Dart e vou fazer o mesmo para o death e finalmente para o para o gender que Ã© um bocadinho diferente lembro que o gender na base de dados Ã© um inteiro ou ou seja este gender que aqui estÃ¡ Ã© uma string mas o que vai para a base de dados tem que ser um inteiro e por isso eu tenho que verificar se o gender for mail entÃ£o aquilo que vai para base dados Ã© um caso contrÃ¡rio Ã© zero tenho o meu 2db concluÃ­do lembro que era aqui que eu queria usÃ¡-lo ou seja ele vai pegar nos dados do Character que recebeu aqui convertÃª-lo para tal map inseri-lo nesta tabela Car atravÃ©s desta entidade esta referÃªncia para a Database vou simplesmente chamar o Database ponto insert e aqui vou inserir um Character aleatÃ³rio para ele ter um ID sempre diferente eu vou-lhe dar aqui um Random vou usar aqui isto Esta funÃ§Ã£o Random Portal Ponto nextint V 100 Portanto o inteiro entre 0 e 100 aleatÃ³rio vou-lhe tambÃ©m dar um name pode ser Pedro e um gender neste caso pode ser mail e nÃ£o vou preencher o nascimento nem a morte e ele vai sempre inserir um Pedro mail mas com um ID diferente cada vez que carregamos no botÃ£o o que eu queria chamar atenÃ§Ã£o este insert Ã© sÃ­ncrono o quer dizer que este onpress vai terminar e isto ainda nÃ£o terminou isto ainda vai ficar a correr lÃ¡ atrÃ¡s nÃ³s nÃ£o estamos nÃ£o vou fazer um disto para nÃ£o prender o ecrÃ£ nÃ£o isto se calhar devia tambÃ©m ter aqui um feature builder associado mas para simplificar agora o cÃ³digo nÃ£o vou preocupar com isso isto na prÃ¡tica NÃ£o Vai Ter grande efeito porque o tempo que demora ele a inserir Ã© suficientemente rÃ¡pido para que eu a seguir possa carregar no get characters from Database e ele funcionar bem sem qualquer problema portanto vou deixar Isto assim falta-me Claro a acrescentar isto Ã  interface criei a funÃ§Ã£o mas nÃ£o criei a interface portanto falta-me aqui o build e Database certo Agora sim cÃ¡ estÃ¡ e vamos inserir ele nÃ£o dÃ¡ feedback nenhum Mas provavelmente inseriu vamos ver nÃ£o inseriu Vamos carregar agora sim cÃ¡ estÃ¡ ele se eu inserir novamente cÃ¡ estÃ¡ ele e podemos tambÃ©m verificar que eh aqui no app inspector fizemos aqui um refresh cÃ¡ estÃ¡ foi gerado um ID 27 um aleatÃ³rio ID 63 o resto dos Campos estÃ£o a nul mas de resto estÃ¡ tudo ok
